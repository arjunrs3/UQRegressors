"""
Plotting
--------
A collection of functions to visualize data generated by UQregressors. 

The supported types of plots are: 
    - Calibration curves 
    - Predicted values vs. true values 
"""

from uqregressors.metrics.metrics import coverage, average_interval_width 
from uqregressors.utils.file_manager import FileManager
import tempfile
import numpy as np 
import matplotlib.pyplot as plt
import seaborn as sns 


def generate_cal_curve(model, X_test, y_test, alphas=None, refit=False, 
                       X_train=None, y_train=None):
    """
    Generate the data for a calibration curve, which can be plotted with plot_cal_curve. 

    Args: 
        model (BaseEstimator): The model for which to generate the calibration curve. 
        X_test (array-like): An array of testing features to generate the calibration curve for. 
        y_test (array-like): An array of testing targets to generate the calibration curve for. 
        alphas (array-like): The complement of the confidence intervals tested. If none, 10 alphas between 0.7 and 0.01 are linearly generated.
        refit (bool): Whether to re-fit the model for each alpha (useful for models like CQR where the underlying regressor depends on alpha).
        X_train (array-like): Training features if refit is True. 
        y_train (array-like): Training targets if refit is True.

    Returns: 
        Tuple(np.ndarray, np.ndarray, np.ndarray): The desired coverages, the empirical coverages, and the average interval widths for each alpha. 
    """
    if (refit == True) and (X_train is None or y_train is None): 
        raise ValueError("X_train and y_train must be given to generate a calibration curve with refit=True")
    alphas = alphas or np.linspace(0.7, 0.01, 10)
    desired_coverage = 1 - alphas 
    coverages = np.zeros_like(desired_coverage)
    avg_interval_widths = np.zeros_like(desired_coverage)

    for i, alpha in enumerate(alphas): 
        # Clone model: 
        with tempfile.TemporaryDirectory() as tmpdirname: 
            fm = FileManager(tmpdirname)
            saved_path = fm.save_model(model, name=None, path=None)
            cloned_model = fm.load_model(model.__class__, path=saved_path)["model"]
        cloned_model.alpha = alpha 
        if refit == True: 
            cloned_model.fit(X_train, y_train)

        mean, lower, upper = cloned_model.predict(X_test)
        coverages[i] = coverage(lower, upper, y_test)
        avg_interval_widths[i] = average_interval_width(lower, upper)

    return desired_coverage, coverages, avg_interval_widths 

def plot_cal_curve(desired_coverage, coverages, show=False, save_dir=None, filename="calibration_curve.png", title=None): 
    """
    Plot a calibration curve with data generated from uqregressors.plotting.plotting.generate_cal_curve. 

    Args: 
        desired_coverage (array-like): An array of the desired coverages for which the model was evaluated.
        coverages (array-like): An array of the empirical coverages achieved by the model for each desired coverage. 
        show (bool): Whether to display the plot after generating it (True) or simply close (False).
        save_dir (str): If not None, the plot will be saved to the directory: save_dir/plots/filename. If associated with a model, 
                        it is recommended that this directory is the directory in which the model is saved. 
        filename (str): The filename, including extension, to which the plots will be saved. 
        title (str): The title included in the plot, if not None.

    Returns: 
        (Union[str, None]): If save_dir is not none, the path to which the file was saved is returned. Otherwise None is returned. 
    """
    plt.figure(figsize=(8, 5))
    sns.set_theme(style='whitegrid')
    sns.lineplot(x=desired_coverage, y=coverages, marker='o', label='Empirical Coverage')
    plt.plot([0, 1], [0, 1], 'k--', label='Ideal (y = x)')
    plt.xlabel('Desired Coverage (1 - alpha)')
    plt.ylabel('Empirical Coverage')
    if title is not None: 
        plt.title(title)
    plt.legend()
    plt.gca().set_aspect('equal', adjustable='box')
    plt.tight_layout()

    if save_dir is not None: 
        fm = FileManager(save_dir)
        save_path = fm.save_plot(plt.gcf(), save_dir, filename, show=show)

        print (f"Saved calibration curve to {save_path}")
        return save_path
    
    else: 
        return None
    
def plot_pred_vs_true(mean, lower, upper, y_true, samples=None, include_confidence=True, show=False, save_dir=None, filename="pred_vs_true.png", title=None, alpha=None):
    """
    Plot predicted vs true values with optional confidence intervals.

    Args:
        mean (array-like): Predicted mean values.
        lower (array-like): Lower bound of prediction intervals.
        upper (array-like): Upper bound of prediction intervals.
        y_true (array-like): True target values.
        samples (int, optional): Number of samples to plot. Defaults to all.
        include_confidence (bool): Whether to plot error bars. Default: True.
        show (bool): Whether to display the plot. Default: False.
        save_dir (str, optional): Directory to save the figure. If None, the figure is not saved.
        filename (str): File name for the plot. Default: "pred_vs_true.png".
        title (str, optional): Title of the plot.
        alpha (float, optional): Confidence level (e.g., 0.1 for 90% interval).

    Returns: 
        (Union[str, None]): The save path if the plot should be saved, otherwise None
    """
    mean = np.asarray(mean)
    lower = np.asarray(lower)
    upper = np.asarray(upper)
    y_true = np.asarray(y_true)

    n = len(y_true)
    idx = np.arange(n)
    if samples is not None:
        samples = min(samples, n)
        idx = np.random.choice(n, samples, replace=False)

    fig, ax = plt.subplots(figsize=(6, 6))
    if include_confidence:
        ax.errorbar(y_true[idx], mean[idx], 
                    yerr=[mean[idx] - lower[idx], upper[idx] - mean[idx]], 
                    fmt='o', ecolor='gray', alpha=0.75, capsize=3, label=f"Predictions w/ CI")
    else:
        ax.scatter(y_true[idx], mean[idx], alpha=0.75, label="Predictions")

    ax.plot([y_true.min(), y_true.max()], [y_true.min(), y_true.max()], 'k--', label="y = x")
    ax.set_xlabel("True values")
    ax.set_ylabel("Predicted values")
    ax.legend()
    
    if alpha is not None:
        ax.text(0.05, 0.95, f"$\\alpha$ = {alpha}", transform=ax.transAxes, va='top')

    if title:
        ax.set_title(title)

    plt.tight_layout()
    if save_dir is not None: 
        fm = FileManager(save_dir)
        save_path = fm.save_plot(plt.gcf(), save_dir, filename, show=show)

        print (f"Saved calibration curve to {save_path}")
        return save_path
    
    else: 
        return None